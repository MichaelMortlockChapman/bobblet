/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import * as THREE from 'three'
import { useImmer } from 'use-immer'
import {Piece, StackPiece, SCENE_CONSTS} from './Pieces.js'
import { PLAYER1, PLAYER2, getTopValue } from './Board.js'
import GhostPiece from './GhostPiece.js'

export const PLAYER1GEOSTR = 'White'
export const PLAYER2GEOSTR = 'Black'

export function Scene(props) {
  const {handleCellAction, handleSelectStackPiece, board, playerStacks, selected, playerTurn} = props

  const { nodes, materials } = useGLTF('/bobblet.glb')

  const ghostRef = useRef()
  const [ghostPieceState, setGhostPieceState] = useState({
    pos: [1,1],
    player: PLAYER1,
    piece: 4,
    visible: true
  })

  const handleStackClick = (player, index) => () => {
    if (player !== playerTurn) {
      return
    }
    handleSelectStackPiece(index)
  }

  // make buttons (boxes) for each board cell
  const createButtons = () => {
    const buttons = []
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        buttons.push(
          <mesh 
            key={`${i} ${j}`} 
            position={[SCENE_CONSTS.boardWidth - i * SCENE_CONSTS.boardWidthDif, SCENE_CONSTS.boardHeight, SCENE_CONSTS.boardDepth - j * SCENE_CONSTS.boardDepthDif]}
            onClick={() => handleCellAction(i,j)}
            onPointerEnter={(e) => {
              setGhostPieceState({ ...ghostPieceState, pos: [i, j], visible: true })
            }}
            onPointerLeave={(e) => {
              setGhostPieceState({ ...ghostPieceState, visible: false })
            }}
            visible={false}
          >
            <boxGeometry args={[0.75,0.1,0.75]}/>
          </mesh>
        )
      }
    }
    return buttons
  }

  const CreatePiece = (i,j,player,piece) => {
    const positionXYZ = [SCENE_CONSTS.boardWidth - i * SCENE_CONSTS.boardWidthDif, SCENE_CONSTS.pieceHeights[piece - 1], SCENE_CONSTS.boardDepth - j * SCENE_CONSTS.boardDepthDif]
    const material = player == PLAYER1 ? materials.WhitePiece : materials.BlackPiece
    const geometry = nodes[`${player == PLAYER1 ? PLAYER1GEOSTR : PLAYER2GEOSTR}${piece}`].geometry
    return <Piece key={`${i} ${j}`} ignoreHover={player !== playerTurn} positionXYZ={positionXYZ} material={material} geometry={geometry} selected={i === selected[0] && j === selected[1]}/>
  }

  const [pieces, setPieces] = useState([])
  useEffect(() => {
    const newPieces = []
    console.log('board change');
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        const item = getTopValue(board[i][j])
        if (item !== undefined) {
          newPieces.push(CreatePiece(i,j,item.player,item.type))
        }
      }
    }
    setPieces(newPieces)
  }, [board])
    
  return (
    <group {...props} dispose={null}>
      <GhostPiece materials={materials} nodes={nodes} ghostRef={ghostRef} state={ghostPieceState}/>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Board.geometry}
        material={materials.Board}
        position={[0, 0.409, 0]}
        />
      <group>
        {createButtons()}
      </group>
      <group>
        {pieces}
      </group>
      {/* <mesh castShadow receiveShadow geometry={nodes.Table.geometry} material={materials.Table} /> */}
      <group>
        <StackPiece
          threeInfo={{materials: materials, nodes: nodes}}
          stackInfo={{playerStacks: playerStacks, player: PLAYER1, index: 0, playerTurn: playerTurn}}
          onClick={handleStackClick(PLAYER1, 0)}
          selected={-PLAYER1 - 1  === selected[0] && 0 === selected[1]}
        />
        <StackPiece
          threeInfo={{materials: materials, nodes: nodes}}
          stackInfo={{playerStacks: playerStacks, player: PLAYER1, index: 1, playerTurn: playerTurn}}
          onClick={handleStackClick(PLAYER1, 1)}
          selected={-PLAYER1 - 1  === selected[0] && 1 === selected[1]}
        />
        <StackPiece
          threeInfo={{materials: materials, nodes: nodes}}
          stackInfo={{playerStacks: playerStacks, player: PLAYER1, index: 2, playerTurn: playerTurn}}
          onClick={handleStackClick(PLAYER1, 2)}
          selected={-PLAYER1 - 1  === selected[0] && 2 === selected[1]}
        />
      </group>
      <group>
        <StackPiece
          threeInfo={{materials: materials, nodes: nodes}}
          stackInfo={{playerStacks: playerStacks, player: PLAYER2, index: 0, playerTurn: playerTurn}}
          onClick={handleStackClick(PLAYER2, 0)}
          selected={-PLAYER2 - 1  === selected[0] && 0 === selected[1]}
        />
        <StackPiece
          threeInfo={{materials: materials, nodes: nodes}}
          stackInfo={{playerStacks: playerStacks, player: PLAYER2, index: 1, playerTurn: playerTurn}}
          onClick={handleStackClick(PLAYER2, 1)}
          selected={-PLAYER2 - 1  === selected[0] && 1 === selected[1]}
        />
        <StackPiece
          threeInfo={{materials: materials, nodes: nodes}}
          stackInfo={{playerStacks: playerStacks, player: PLAYER2, index: 2, playerTurn: playerTurn}}
          onClick={handleStackClick(PLAYER2, 2)}
          selected={-PLAYER2 - 1 === selected[0] && 2 === selected[1]}
        />
      </group>
    </group>
  )
}

useGLTF.preload('/bobblet.glb')