/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import * as THREE from 'three'

export function Scene(props) {
  const { nodes, materials } = useGLTF('/bobblet.glb')
  
  // const playerStacks = [[4, 4, 4], [4, 4, 4]]

  // const createStackPiece = (positionXZZ, player, piece) => {
  //   const playerString = player == 0 ? 'White' : 'Black'
  //   return ( <>
  //     {piece > 0 && <mesh
  //       castShadow
  //       receiveShadow
  //       geometry={ghostRef.current.geometry = nodes[`${playerString}${piece}`].geometry}
  //       material={materials.WhitePiece}
  //       position={[0, 0.598, -3.146]}
  //     />}
  //   </>)
  // }

  const pieceHeights = [1.181, 1.326, 1.399, 1.417]
  const ghostRef = useRef()
  const ghostBlackMat = materials.BlackPiece.clone()
  ghostBlackMat.transparent = true
  ghostBlackMat.opacity = 0.3
  const ghostWhiteMat = materials.WhitePiece.clone()
  ghostWhiteMat.transparent = true
  ghostWhiteMat.opacity = 0.3
  // used to show a hover ghost on placement
  const updateGhostPlacement = (positionXZ, player, piece) => {
    if (ghostRef.current == null) {
      return;
    }
    const playerString = player == 0 ? 'White' : 'Black'
    
    ghostRef.current.visible = true
    // can't set position but need to set x,y,z
    ghostRef.current.position.x = positionXZ[0]
    ghostRef.current.position.y = pieceHeights[piece - 1]
    ghostRef.current.position.z = positionXZ[1]
    ghostRef.current.material = player == 0 ? ghostWhiteMat : ghostBlackMat
    ghostRef.current.geometry = nodes[`${playerString}${piece}`].geometry
  }
  const hideGhost = () => {
    if (ghostRef.current == null) return;
    ghostRef.current.visible = false
  }

    // make buttons (boxes) for each board cell
    const boardWidth = 1.55; const boardDepth = 1.55;
    const boardWidthDif = 1.035; const boardDepthDif = 1.035
    const boardHeight = 0.85
    const createButtons = () => {
      const buttons = []
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          buttons.push(
            <mesh 
              key={`${i} ${j}`} 
              position={new THREE.Vector3(boardWidth - i * boardWidthDif, boardHeight, boardDepth - j * boardDepthDif)}
              onClick={(e) => {
                e.stopPropagation()
                console.log(`${i} ${j}`);
              }}
              onPointerEnter={(e) => updateGhostPlacement([boardWidth - i * boardWidthDif, boardDepth - j * boardDepthDif], 0, 4)}
              onPointerLeave={(e) => hideGhost()}
              visible={false}
            >
              <boxGeometry args={[0.75,0.1,0.75]}/>
            </mesh>
          )
        }
      }
      return buttons
    }
    
    return (
      <group {...props} dispose={null}>
      <mesh
        className={"GhostPiece"}
        castShadow
        receiveShadow
        visible={true}
        ref={ghostRef}
        geometry={nodes.Black1.geometry}
        material={ghostWhiteMat}
        position={[-1.542, 1.181, -1.535]}
        />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Board.geometry}
        material={materials.Board}
        position={[0, 0.409, 0]}
        />
      <group>
        {createButtons()}
      </group>
      {/* <mesh castShadow receiveShadow geometry={nodes.Table.geometry} material={materials.Table} /> */}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.BlackStackRef2.geometry}
        material={materials.BlackPiece}
        position={[0, 0.598, 3.5]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.BlackStackRef3.geometry}
        material={materials.BlackPiece}
        position={[1.107, 0.598, 3.5]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.BlackStackRef1.geometry}
        material={materials.BlackPiece}
        position={[-1.189, 0.598, 3.5]}
      />
      {}
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.WhiteStackRef1.geometry}
        material={materials.WhitePiece}
        position={[-1.189, 0.598, -3.146]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.WhiteStackRef3.geometry}
        material={materials.WhitePiece}
        position={[1.107, 0.598, -3.146]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.WhiteStackRef2.geometry}
        material={materials.WhitePiece}
        position={[0, 0.598, -3.146]}
      />
    </group>
  )
}

useGLTF.preload('/bobblet.glb')